<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ScaleX Marketing Dashboard</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- D3.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- D3 Sankey -->
  <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

  <!-- D3 Chord -->
  <script src="https://d3js.org/d3-chord.v1.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

  <style>
    body {
      font-family: system-ui, Arial;
      background:#f6f8fb;
      padding:25px;
    }

    h1 { margin-bottom: 10px; }
    .container { max-width: 1250px; margin: auto; }

    .controls {
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom:20px;
    }

    input {
      padding:6px;
      border-radius:6px;
      border:1px solid #ccc;
    }

    .row {
      display:flex;
      flex-wrap:wrap;
      gap:20px;
      margin-bottom:25px;
    }

    .card {
      background:white;
      border-radius:10px;
      padding:15px;
      box-shadow:0 6px 18px rgba(16,24,40,0.06);
      flex:1 1 380px;
      min-width:360px;
    }

    canvas {
      width:100% !important;
      height:300px !important;
    }

    table {
      width:100%;
      border-collapse:collapse;
      font-size:14px;
    }
    th, td {
      padding:8px;
      border-bottom:1px solid #eee;
    }

    /* Heatmap */
    .heatmap text {
      font-size:12px;
      fill:black;
    }

    #chordChart, #sankeyChart, #heatmapChart {
      width:100%;
      height:400px;
    }
  </style>
</head>

<body>
<div class="container">

  <h1>ScaleX Marketing Dashboard</h1>

  <div class="controls">
    <label>Days: <input id="days" type="number" min="1" max="365" value="30" /></label>
    <button id="refreshAll">Refresh</button>
  </div>

  <!-- EXISTING CHARTS -->
  <div class="row">
    <div class="card"><h3>Lead Count</h3><canvas id="leadCount"></canvas></div>
    <div class="card"><h3>Sessions Over Time</h3><canvas id="sessionsOverTime"></canvas></div>
  </div>

  <div class="row">
    <div class="card"><h3>Sessions by Channel</h3><canvas id="sessionsByChannel"></canvas></div>
    <div class="card"><h3>Leads by Campaign</h3><canvas id="leadsByCampaign"></canvas></div>
  </div>

  <div class="row">
    <div class="card"><h3>Source / Medium Mix</h3><canvas id="sourceMediumPie"></canvas></div>
    <div class="card">
      <h3>Top Landing Pages</h3>
      <table>
        <thead><tr><th>Landing Page</th><th>Sessions</th></tr></thead>
        <tbody id="landingPagesBody"></tbody>
      </table>
    </div>
  </div>

  <!-- NEW MULTICHANNEL CHARTS -->
  <h2 style="margin-top:40px;">Advanced Multi-Channel Behaviour</h2>

  <div class="row">
    <div class="card" style="min-width:500px;">
      <h3>Audience Overlap (Heatmap)</h3>
      <div id="heatmapChart"></div>
    </div>
  </div>

  <div class="row">
    <div class="card" style="min-width:500px;">
      <h3>First-Touch → Lead-Touch Flow (Sankey)</h3>
      <svg id="sankeyChart" width="600" height="450"></svg>
    </div>
  </div>

  <div class="row">
    <div class="card" style="min-width:500px;">
      <h3>Channel Assist Score (Chord Diagram)</h3>
      <svg id="chordChart" width="550" height="550"></svg>
    </div>
  </div>

</div>

<script>
const API = "https://scalex-adapter-268453003438.europe-west1.run.app";

// --------------- Helper Fetch ------------------
async function fetchChart(chart, days=30) {
  const url = `${API}/chart-data?chart=${chart}&days=${days}`;
  const r = await fetch(url);
  const j = await r.json();
  return j.rows || [];
}

// --------------- EXISTING CHARTS (Chart.js) ------------------
function normalizeDay(d) {
  if (!d) return "";
  if (typeof d === "object" && d.value) return d.value;
  return d;
}

let line1, line2, bar1, bar2, pie1;

async function loadLeadCount(days){
  let rows = await fetchChart("lead_count", days);
  rows = rows.map(r => ({day: normalizeDay(r.day), value: r.leads}));

  const ctx = document.getElementById("leadCount");
  if (line1) line1.destroy();
  line1 = new Chart(ctx, {
    type:"line",
    data:{ labels:rows.map(r=>r.day), datasets:[{label:"Leads", data:rows.map(r=>r.value), fill:true}]}
  });
}

async function loadSessionsOverTime(days){
  let rows = await fetchChart("sessions_over_time", days);
  rows = rows.map(r => ({day: normalizeDay(r.day), value: r.sessions}));

  const ctx = document.getElementById("sessionsOverTime");
  if (line2) line2.destroy();
  line2 = new Chart(ctx, {
    type:"line",
    data:{ labels:rows.map(r=>r.day), datasets:[{label:"Sessions", data:rows.map(r=>r.value)}] }
  });
}

async function loadSessionsByChannel(days){
  let rows = await fetchChart("sessions_by_channel", days);
  rows = rows.map(r => ({key:r.channel, value:r.sessions}));

  const ctx = document.getElementById("sessionsByChannel");
  if (bar1) bar1.destroy();
  bar1 = new Chart(ctx, {
    type:"bar",
    data:{ labels:rows.map(r=>r.key), datasets:[{data:rows.map(r=>r.value)}] },
    options:{ indexAxis:"y" }
  });
}

async function loadLeadsByCampaign(days){
  let rows = await fetchChart("leads_by_campaign", days);
  rows = rows.map(r => ({key:r.campaign, value:r.leads}));

  const ctx = document.getElementById("leadsByCampaign");
  if (bar2) bar2.destroy();
  bar2 = new Chart(ctx, {
    type:"bar",
    data:{ labels:rows.map(r=>r.key), datasets:[{data:rows.map(r=>r.value)}] },
    options:{ indexAxis:"y" }
  });
}

async function loadSourceMediumPie(days){
  let rows = await fetchChart("source_medium_pie", days);
  const ctx = document.getElementById("sourceMediumPie");
  if (pie1) pie1.destroy();
  pie1 = new Chart(ctx, {
    type:"pie",
    data:{ labels:rows.map(r=>r.label), datasets:[{data:rows.map(r=>r.value)}]}
  });
}

async function loadTopLandingPages(days){
  let rows = await fetchChart("top_landing_pages", days);
  let body = document.getElementById("landingPagesBody");
  body.innerHTML = "";
  rows.forEach(r => {
    let tr = document.createElement("tr");
    tr.innerHTML = `<td>${r.landing_page}</td><td>${r.sessions}</td>`;
    body.appendChild(tr);
  });
}

// ----------------- NEW MULTICHANNEL VISUALS ----------------------

// ----------------- 1. AUDIENCE OVERLAP HEATMAP -------------------
async function loadAudienceOverlap(days){
  const data = await fetchChart("audience_overlap", days);

  const channels = [...new Set(data.map(d=>d.channel_a).concat(data.map(d=>d.channel_b)))];

  const matrix = channels.map(a =>
    channels.map(b => {
      const row = data.find(d=>d.channel_a===a && d.channel_b===b);
      return row ? row.users : 0;
    })
  );

  const container = d3.select("#heatmapChart");
  container.selectAll("*").remove();

  const width = 450, height = 450;
  const svg = container.append("svg").attr("width",width).attr("height",height);

  const gridSize = Math.floor(width / channels.length);

  const color = d3.scaleSequential(d3.interpolateOrRd)
    .domain([0, d3.max(matrix.flat())]);

  channels.forEach((ch,i)=>{
    svg.append("text")
      .attr("x", i*gridSize + gridSize/2)
      .attr("y", 10)
      .attr("text-anchor","middle")
      .text(ch);
    svg.append("text")
      .attr("x", 0)
      .attr("y", i*gridSize + gridSize/2 + 10)
      .text(ch);
  });

  matrix.forEach((row,i)=>{
    row.forEach((val,j)=>{
      svg.append("rect")
        .attr("x", j*gridSize)
        .attr("y", i*gridSize + 15)
        .attr("width", gridSize-2)
        .attr("height", gridSize-2)
        .attr("fill", color(val));

      svg.append("text")
        .attr("x", j*gridSize + gridSize/2)
        .attr("y", i*gridSize + gridSize/2 + 15)
        .attr("text-anchor","middle")
        .attr("fill","black")
        .text(val);
    });
  });
}

// ----------------- 2. FIRST → LEAD SANKEY -------------------------
async function loadSankey(days){
  const rows = await fetchChart("first_to_last_touch", days);

  const nodes = {};
  const links = [];

  rows.forEach(r=>{
    if (!nodes[r.first_channel]) nodes[r.first_channel] = {name:r.first_channel};
    if (!nodes[r.lead_channel]) nodes[r.lead_channel] = {name:r.lead_channel};

    links.push({
      source: r.first_channel,
      target: r.lead_channel,
      value: r.users
    });
  });

  const nodeList = Object.values(nodes);

  // Convert node names → index
  const nodeIndex = {};
  nodeList.forEach((n,i)=> nodeIndex[n.name] = i);

  const sankeyLinks = links.map(l=>({
    source: nodeIndex[l.source],
    target: nodeIndex[l.target],
    value: l.value
  }));

  d3.select("#sankeyChart").selectAll("*").remove();

  const width = 600, height = 450;
  const svg = d3.select("#sankeyChart");

  const sankey = d3.sankey()
      .nodeWidth(20)
      .nodePadding(20)
      .extent([[1, 1], [width-1, height-5]]);

  const graph = sankey({
    nodes: nodeList.map(d=>Object.assign({},d)),
    links: sankeyLinks
  });

  svg.append("g")
    .selectAll("rect")
    .data(graph.nodes)
    .join("rect")
      .attr("x", d=>d.x0)
      .attr("y", d=>d.y0)
      .attr("height", d=>d.y1-d.y0)
      .attr("width", d=>d.x1-d.x0)
      .attr("fill","steelblue");

  svg.append("g")
    .selectAll("path")
    .data(graph.links)
    .join("path")
      .attr("d", d3.sankeyLinkHorizontal())
      .attr("stroke", "#999")
      .attr("stroke-width", d=>Math.max(1, d.width))
      .attr("fill","none");

  svg.append("g")
    .selectAll("text")
    .data(graph.nodes)
    .join("text")
      .attr("x", d=>d.x0 < width/2 ? d.x1+6 : d.x0-6)
      .attr("y", d=> (d.y1+d.y0)/2 )
      .attr("dy","0.35em")
      .attr("text-anchor", d=>d.x0 < width/2 ? "start":"end")
      .text(d=>d.name);
}

// ----------------- 3. CHANNEL ASSIST CHORD -------------------------
async function loadChord(days){
  const rows = await fetchChart("channel_assists", days);

  const channels = [...new Set(rows.flatMap(r=>[r.assist_channel, r.conversion_channel]))];

  const index = {};
  channels.forEach((c,i)=> index[c]=i);

  const matrix = Array.from({length:channels.length},
    ()=> Array(channels.length).fill(0));

  rows.forEach(r=>{
    matrix[index[r.assist_channel]][index[r.conversion_channel]] = r.assists;
  });

  const width = 550, height = 550;
  const outerRadius = width/2 - 40;
  const innerRadius = outerRadius - 20;

  d3.select("#chordChart").selectAll("*").remove();

  const svg = d3.select("#chordChart")
    .attr("viewBox",[0,0,width,height])
    .append("g")
    .attr("transform",`translate(${width/2},${height/2})`);

  const chord = d3.chord().padAngle(0.05).sortSubgroups(d3.descending);
  const arcs = chord(matrix);

  const color = d3.scaleOrdinal(d3.schemeTableau10);

  svg.append("g")
    .selectAll("g")
    .data(arcs.groups)
    .join("g")
      .append("path")
      .attr("fill", d=>color(d.index))
      .attr("d", d3.arc().innerRadius(innerRadius).outerRadius(outerRadius));

  svg.append("g")
    .selectAll("text")
    .data(arcs.groups)
    .join("text")
      .attr("transform", d=>{
        const angle = (d.startAngle + d.endAngle)/2;
        return `rotate(${angle*180/Math.PI - 90}) translate(${outerRadius+5})`;
      })
      .attr("dy","0.35em")
      .attr("text-anchor","start")
      .text(d=>channels[d.index]);

  svg.append("g")
    .attr("fill-opacity",0.7)
    .selectAll("path")
    .data(arcs)
    .join("path")
      .attr("d", d3.ribbon().radius(innerRadius))
      .attr("fill", d=>color(d.target.index))
      .attr("stroke", "#333");
}

// ----------------- LOAD EVERYTHING -------------------------------
async function refreshAllCharts(){
  const days = Number(document.getElementById("days").value);

  await Promise.all([
    loadLeadCount(days),
    loadSessionsOverTime(days),
    loadSessionsByChannel(days),
    loadLeadsByCampaign(days),
    loadSourceMediumPie(days),
    loadTopLandingPages(days),
    loadAudienceOverlap(days),
    loadSankey(days),
    loadChord(days)
  ]);
}

document.getElementById("refreshAll").addEventListener("click", refreshAllCharts);

// initial load
refreshAllCharts();

</script>

</body>
</html>
